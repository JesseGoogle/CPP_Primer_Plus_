#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

/*假设计算机的地址位为 32位小端存储*/
/*
    先解释一下何为 32位小端存储：
    在 32 位系统中，数据的低字节存储在低地址中，
    而高字节存储在高地址中。

    比如有一个 int 类型的数据：0x12345678，按照上述标准，它是这么存储的（从低到高）：
    byte 1: 0x78    低
    byte 2: 0x56
    byte 3: 0x34
    byte 4: 0x12    高

*/

/*假设计算机的数据存储方式为：
 32位小端存储*/
int main(int argc, char const *argv[])
{
#if true

    /*声明一个 无符号短整型数组 a 存储了五个 16进制的数字*/
    unsigned short a[5] = {0x1234, 0x5678, 0x9ABC, 0xDEF0, 0x55AA};

    /*
        这条语句可以分为以下 4 步：
        1）先取数组 a 的地址
        2）指针偏移 （直接偏移了一整个数组的字节数）
        3）转换成无符号短整型指针类型
        4）赋值给无符号短整型指针类型变量 ptr_1，
        此时 ptr_1 指向了数组 a 的后面两字节的数据，此时如果解引用这个指针是越界访问的。
    */
    unsigned short *ptr_1 = (unsigned short *)(&a + 1);

    /*
        这条语句可以分为以下 4 步：
        1）a 转换成 无符号整型指针类型
        2）指针偏移 （偏移 4 字节）
        3）赋值给无符号整型指针类型变量 ptr_2
    */
    unsigned int *ptr_2 = (unsigned int *)a + 1;

    /*
        输出语句：
        1）*(a + 1) = 0x5678 （这个最简单，不解释了）

        2）ptr_1 是 无符号短整型指针 类型，
        指向了数组 a 的后面两字节的数据，-1 就是向左偏移两个字节，
        此时它应该指向了数组 a 的最后一个元素，解引用一下就是 0x55AA

        3）ptr_2 是 无符号整型指针类型，此时它指向了数组 a 的第二和第三个元素，
        解引用此指针将一次性读取 4 个字节，结果是：0xDEF09ABC
    */
    printf("%x %x %x\n", *(a + 1), *(ptr_1 - 1), *ptr_2);
#endif

    
    return 0;
}
